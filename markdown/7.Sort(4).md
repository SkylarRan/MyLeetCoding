# 排序优化：如何实现一个通用的、高性能的排序算法

## 如何选择合适的排序算法？
![Alt](img/sortCompare.jpg)

线性排序算法的适用场景比较特殊，所以在写通用的排序算法时不能用线性排序。 

如果对小规模数据排序时，可以选择时复为O（n^2）的算法；对大规模数据排序，要用时复为O（nlogn）的算法。 故通用排序算法首选时复为O（nlogn）的算法。

归并算法最好、最坏、平均情况的时复都是O（nlogn），但是在合并函数有使用额外的临时数组，故空复为O（n）。对于大规模数据来说，使用归并算法空间耗费较大，这是致命缺点。

快速排序是原地且不稳定排序，通常时复为O（nlogn），在最坏情况下，需要进行n次分区，时复为O（n^2）。但对分区点的获取进行优化，可以避免最坏情况。所以快排比归并更受欢迎。

## 如何优化快速排序？
理想情况：被分区点分开的两个区中，数据的数量差不多。
如果很粗暴地选择第一个元素或最后一个元素，很容易发生极端情况，使时复退化到O（n^2）。所以我们要选择合适的分区点，尽可能让每次分区都比较均匀。

1. 三数取中法
从待分区数组中取出首、尾和中间三个元素进行对比，找出中间值作为分区点。
如果分区数组中元素很多，可以采取“五数取中”或“十数取中”。

2. 随机法
从待分区数组中随机选取一个元素作为分区点。

注意： 快速排序是递归实现的，而递归要警惕堆栈溢出。为了避免快排因递归过深而堆栈过小，导致堆栈溢出。两种解决办法：
1. 限制递归深度。 一旦递归的深度超过了事先设定的阈值，就停止递归。
2. 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没了系统栈大小的限制。

## 举例分析排序函数