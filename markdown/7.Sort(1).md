# 冒泡、插入、选择排序 O（n^2）

## 如何分析一个排序算法？
1. 执行效率
* 最好、最坏、平均时间复杂度
    > 明确最好、最坏情况对应的原始数据是什么
    >
    > 通过时间复杂度来对比区分排序算法在不同数据下的性能表现。 
* 时间复杂度的系数、常数和低阶
    > 往往要排序的数据规模n是确定的，对于同一阶时间复杂度的排序算法性能对比时要考虑时复的系数、常数和低阶
* 比较次数和交换（移动）次数
    > 在分析算法的执行效率时，也需要把比较和交换（移动）次数考虑进来。
2. 内存消耗
    > 内存消耗是通过空间复杂度来衡量的，在排序算法中，进入一个“原地排序”（sorted in place）的概念。原地排序算法，特指空间复杂度为O（1）的排序算法
3. 稳定性
    > 排序数据中若存在值相同的元素， 排序后相同元素未交换位置的算法即为稳定算法。 
    > 
    > 例如对于订单按照时间从早到晚，金额从小到大排序。 若先按金额排序，在按时间排序，金额相同时间不同的订单可能会交换位置。 若先按时间排序，再按金额排序，相同金额的订单仍然按照时间进行排序，这样排序稳定性更高。 

## 冒泡排序
1. 进行n-1轮排序，相邻元素比较，每轮排序选出较大值
2. 优化：某轮排序无数据交换则停止外层循环
* 空间复杂度为O（1），属于原地排序
* 相同元素不交换顺序，属于稳定的排序
* 平均时复O（n^2）
    > 最好情况:正序, 时复为O（n）,有序度为(n-1)+...+2+1 = n(n-1)/2(满有序度)
    >
    > 最坏情况：逆序， 时复为O（n^2），有序度为0
    >
    > 平均有序度为n(n-1)/4,即为交换次数，比较次数是多于交换次数的，时复上限为O（n^2），故平均时复为O（n^2）

## 插入排序
1. 进行n-1轮排序，从后往前比较，将待排元素插入到已排序数组中的正确位置上
2. 数据移动的个数总和 = 逆序度
* 属于原地排序
* 稳定的排序
* 平均时复O（n^2）
    >  最好情况:正序, 比较n-1次，时复为O（n）
    >
    > 最坏情况：逆序，逆序度为n(n-1)/2，比较与交换次数为逆序度，相当于在数组首位插入元素，时复为O（n^2）
    >
    > 数组中插入一个数据的平均时复为O（n），要遍历插入n次，故平均时复为O（n^2）

## 选择排序
1. 进行n-1轮排序，每次选择待排元素中的最小元素， 交换最小元素与即将待排位置上的元素
2. 比较次数不变，为n(n-1)/2
* 属于原地排序
* 不稳定， 如 3  2 4 3 5 1， 第一轮就把第一个3和1交换了位置，即两个3交换了位置
* 最好、最坏、平均时复都是O(n^2)，因为比较次数不变，只是交换次数不同。

## 

排序算法| 原地排序 | 是否稳定 | 平均时复 |最好时复 | 最坏时复
--|--|--|--|--|--
冒泡 | 是 | 是 | O(n^2) | O(n) | O(n^2) 
插入 | 是 | 是 | O(n^2) | O(n) | O(n^2) 
选择 | 是 | 否 | O(n^2) | O(n^2) | O(n^2) 


## 为什么插入排序比冒泡排序更受欢迎？
冒泡排序和插入排序的交换（移动）次数都等于原始数据的逆序度，但冒泡排序的交换操作是3句， 插入排序的移动操作只是1句。 实际中插入排序比冒泡排序的执行效率高。要把性能优化做到极致，当然首选插入排序。

## 插入排序的优化： 希尔排序