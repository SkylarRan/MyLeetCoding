# 堆
堆是一种特殊的树，需要满足两点：
1. 堆是一棵完全二叉树。
    > 完全二叉树：除去最后一层，其余节点都是满的（满二叉树）， 最后一层的子节点靠左排列。
2. 堆中每个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
    > 等价于 堆中每个节点的值都大于等于（或小于等于）其左右子节点的值。 “大于等于”的叫做“大顶堆”，“小于等于”的叫做“小顶堆”。

    ![](../img/heap.jpg)

    上图中1和2是大顶堆， 3是小顶堆，4不是完全二叉树，故不是堆。还可看出，对于同一组数据，可以构建多种形态的堆。

## 堆的实现

堆是一棵完全二叉树，故用数组存储更省空间，其中根节点下标为i=1， 左子节点下标为2 * i， 右子节点下标为2 * i +1， 父节点下标为i/2。

1. 往堆中插入一个元素

    > 若直接将新元素作为叶子节点插入堆中，就破坏了堆的特性，于是需要进行调整，调整的过程叫做堆化（heapify）。堆化有两种方法，从下往上和从上往下。 现在举例从下往上。

    ![](../img/heap_insert.jpg)
    
    堆化过程：顺着节点路径向上或者向下，进行对比、交换。

    ![](../img/heapify.jpg)

2. 删除堆顶元素

    > 从堆的第二点定义，堆中的每个节点都大于等于（小于等于）其子树中每个节点的值，可以得知堆顶元素是最大值（最小值）。

    > 以大顶堆为例，堆顶元素为最大值，删除堆顶元素，就需要找到第二大元素放在根节点处。

    ![](../img/heap_delete_1.jpg)

    > 若直接删除堆顶元素，从子节点中找到最大值替换，迭代替换过程，直到叶子节点，但这样会出现数组空洞，就不符合完全二叉树的定义，也就不是堆了。

    > 换个思路，用最后一个节点替换根节点，然后进行从上而下的堆化过程。

    ![](../img/heap_delete_2.jpg)


3. 堆化的时复与完全二叉树的高度成正比， 完全二叉树的高度不会超过log2 N，所以堆化的时复为O（logn）。堆的插入与删除操作就是堆化过程，所以堆的插入与删除堆顶元素的时复是O（logn）

## 基于堆实现排序（堆排序：时复O（nlogn），原地排序，不稳定）
### 建堆（两种方法）
1. 从下往上堆化， 数组处理从前往后
    > 所有元素依次插入堆中，成为最后一个叶子节点，然后再每次插入后对最后一个叶子节点进行从下往上堆化。

2. 从上往下堆化， 数组处理从后往前（从第一个非叶子节点开始）
    > 将所有元素放入数组中， 然后从第一个非叶子节点开始进行从上往下堆化。第一个非叶子节点为中点(已存储的节点个数self.count//2

    ![](../img/heap_create_1.jpg)
    ![](../img/heap_create_2.jpg)

> 表面上，堆化的时复为O(logn),要堆化的节点个数为n/2,故建堆的时复为O(nlogn)。但这个答案还不够精确。

> 节点在堆化过程中，比较和交换的次数是与该结点的高度k成正比的。如第一个非叶子节点只需要向下比较1次，而根节点要向下比较高度k次。

![](../img/heap_height.jpg)

上图展示了非叶子节点的高度，叶子节点的高度为0。 对所有非叶子节点的高度求和：
![](../img/heap_height_sum.jpg)

对S1 左右两边*2，得S2，左右两边再相减得S=2^(h+1) - h - 2, 代入h = log2 N 得 S = 2N - log2 N -2 = O(n)。所以，建堆的时间复杂度为O(n)。



### 排序
完成建堆后，堆顶元素都是最大元素， 每次都将堆顶元素与数组未排序的最后一个节点交换，也就是依次拿到未排序的最大元素，这样就实现了堆排序。而拿取堆顶元素后相当于删除堆顶元素，进行堆化。

1. 堆排序分为建堆和排序两步，建堆的时复为O(n),排序中遍历n次，每次堆化为logn，时复为O(nlogn)，故堆排序的时复为O(nlogn)。
2. 堆排序过程中只有交换操作会涉及个别临时空间，故是原地排序。
3. 堆排序中将最后一个节点元素与堆顶节点元素互换，所以不是稳定的排序算法

## 为什么快排比堆排序性能好?
快排：一般选择最后一个元素作为分区元素，从第一个元素开始，维护一个指针i从0开始， 若大于分区元素，不动，若小于分区元素，将该元素与下标为i的元素交换，直到分区元素，将分区元素与下标为i的元素交换。
分区元素选的好，则需log2 N次分区，分区过程中遍历n次，故快排的时复为O(nlogn),不稳定，原地排序。

1. 堆排序数据访问方式没有快排友好
    > 快排中数据是依次顺序访问的，堆排序中数据是跳着访问的，如堆化过程中数据访问会出现下标为1,2,4,8的情况，而快排是局部顺序访问，这样对CPU缓存不友好。

2. 对于同样的数据，堆排序的交换次数要多于快排
    > 快排交换的次数不会比逆序度更多，而堆排序的建堆过程可能会增加原始数据的逆序数，从而是交换次数增加。

## 堆的应用