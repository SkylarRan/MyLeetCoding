# 为什么散列表和链表经常会一起使用？

## LRU缓存淘汰算法

利用链表实现：

维护一个按照访问时间从小到大（按入队出队来说是从大到小）排序的链表，结点越靠近尾部，越是最近访问的数据。
访问一个数据，若不存在于链表中，因为缓存大小有限，当缓存空间足够时，直接将新数据放在尾部；当缓存空间不足时，删除链表头部结点，并将新数据放在尾部。
若存在于链表中，将该结点移动到尾部。
因为查找数据需要遍历链表，所以基于链表实现的LRU缓存淘汰算法的时复为O（n）。

一个缓存系统主要包括3个操作：
1. 在缓存中查找一个数据
2. 向缓存中添加一个数据
3. 从缓存中删除一个数据

采用散列表+链表的组合方式，可以将这3个操作的时复降为O（1）。

![Alt](../img/LRU_hashtable_linkedlist.jpg)

图中的散列表是通过链表法来解决散列冲突的，所以横向链表为散列表的拉链，同时结合着一条双向链表。故图中结点data指结点数据，prev和next指双向链表的前后指针， hnext指散列表拉链的下一指针。双向链表需要维护一个头结点、尾结点和结点个数（用来判满）。

*查找* 通过散列函数计算散列值，找到对应的散列槽位，然后遍历拉链查找数据，拉链的结点个数k = n/m(散列表数据总个数/槽位个数)， 所以散列表查找操作的时复接近O（1）。找到数据后将它移动到双向链表的尾部，时复为O(1)。故缓存查找的时复接近O（1）。

*添加* 先查找是否存在于缓存中。若存在，将该数据移动到链表尾部。若不存在，当缓存已满时，删除双向链表的头结点，并将该数据加到链表尾部；当缓存未满时，直接将该数据加到链表尾部。时复接近O（1）

*删除* 先在缓存中找到该结点， 然后从双向链表中删除该结点，双向链表中存放了前后指针，所以找到该结点后直接删除结点的时复为O（1）。


## Java LinkedHashMap

Java的HashMap是通过散列表实现的 ，但散列表存储是乱序的， LinkedHashMap继承了HashMap，linked代表的是双向链表，做到了按顺序存储，且最新访问的数据会放到链尾。

```

// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序
HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}

```

打印结果是1,2,3,5

首先四个put后，双向链表的存放顺序是3,1,5,2。

接着m.put(3, 26)，查询找到key=3的结点，将该结点移动到链表尾部（包含value值修改），存放顺序变成1,5,2,3。

接着m.get(5)，查询找到key=5的结点，将该结点移动到链表尾部，故存放顺序为1,2,3,5.

按照访问时间排序的LinkedHashMap实际上就是一个支持LRU缓存淘汰算法的缓存系统。


## 思考
1. 今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？

使用双向链表是为了维护前后指针，做到不用遍历链表，便可直接插入尾结点和删除结点，时复为O（1）。 而使用单链表插入尾结点或者删除结点的时复为O（n），如果硬要做到O（1），在查找结点时使用双指针记录要删除结点的前一结点。

2. 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：
    - 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
    - 查找积分在某个区间的猎头 ID 列表；
    - 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。

根据ID和猎头信息对象建立散列表，快速查找、删除、更新的时复是O（1）。
根据积分和猎头信息对象数组建立跳表（积分从小到大排序的链表+索引），查找的时复是O（logn）。
只能遍历跳表中维护的链表，时复为O（n），效率极低。
