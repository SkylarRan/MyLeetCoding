# 树

![Alt](../img/tree.jpg)

- 根节点： 没有父节点的节点，E
- 父节点： A是B的父节点
- 子节点： B是A的子节点
- 兄弟节点： B、C、D是兄弟节点
- 叶子节点： 没有子节点的节点，G、H、I、J、K、L

![Alt](../img/tree_height_deepth_level.jpg)

- 节点的高度：节点到叶子节点的最长路径（边数）
- 节点的深度：根节点到这个节点的路径（边数）
- 节点的层数：节点的深度 + 1
- 树的高度： 根节点的高度

## 二叉树（Binary Tree）

每个节点最多只有左右两个子节点。

- 满二叉树：除去叶子节点，每个节点都有左右两个子节点
- 完全二叉树： 最后一层叶子节点的都从左边开始排序，除去最后一层就是满二叉树。

## 二叉树的存储
1. 基于指针或引用的二叉链式存储法
    
    每个结点含有3个属性，data表示存储对象数据，left和right指针分别表示左右子节点。

![Alt](../img/binaryTreeBaseLinkedList.jpg)

2. 基于数组的顺序存储法

    把根节点存放在下标i=1的位置，则它的左子节点的下标为i = 2 * 1 = 2，它的右子节点的下标为i = 2 * 1 + 1 = 3，所有节点X的存放位置下标为i，则它的左子节点存放在2i，右子节点存放在2i+1

![Alt](../img/binaryTreeBaseArray.jpg)

若是一棵完全二叉树，采用数组存储只会浪费下标为0的内存空间。若是一颗普通的树，会浪费数组的多个内存空间。

所以对于完全二叉树，顺序存储是最省内存的方式，因为不需要像链表存储额外的左右子节点的指针，这是完全二叉树要求最后一层子节点靠左的原因。

## 二叉树的遍历

![Alt](../img/binaryTreeTranverse.jpg)

按层遍历：借助队列，按层依次入队， 遍历下一层节点时，先出队拿到节点，再入队该结点存在的左右子节点

## 二叉查找树（Binary Search Tree）

> 任意一个节点，其左子树中每个节点的值都小于该节点的值，其右子树中每个节点的值都大于该节点的值
