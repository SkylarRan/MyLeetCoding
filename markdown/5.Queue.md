# 队列
#### 先进先出， 队尾入队，对头出队， 和栈一样是操作受限的线性表结构
#### 顺序队列：用数组实现（tail == size 时， 整体数据一次搬移)
#### 链式队列：用链表实现

## 环形队列
> 队空： head == tail
>
> 队满： head == （tail + 1）% size
>
> 队满时，tail指向最后一个空位置，环形队列会浪费一个内存空间

## 阻塞队列和并发队列
> 阻塞队列就是在队列的基础上增加了阻塞操作。简单来说，当队列为空时，出队操作就会被阻塞，
直到有队列中有数据才能返回。当队满时，入队操作会被阻塞，直到队列中有空闲位置再插入数据再返回。
>
> 基于阻塞队列可以实现“生产者-消费者”模型。
>
> 并发队列：指线程安全的队列。

## 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？
> 1. 采用非阻塞方式，直接拒绝请求
> 2. 采用阻塞方式，使用阻塞队列将请求排队，等到有空闲线程时，取出排队中的请求进行处理
    > * 若用链表实现阻塞队列，则是实现一个支持无限排队的无界队列，可能导致过多的请求排队，
    处理请求的响应时间过长。所以针对响应时间比较敏感的系统，链式阻塞队列不太合适。
    > * 若用数组实现阻塞队列，则是实现一个支持有限排队的有界队列。当线程池中排队的请求超过队列大小时，
    则拒绝接下来的请求。所以顺序阻塞队列更适合响应时间敏感的系统。但要设置合理的队列大小， 太大则导致
    等待请求过多，太小会使得资源利用不充分，没有发挥最大性能。

#### 实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。