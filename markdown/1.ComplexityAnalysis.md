# 复杂度分析

> 计算机讲求的是运行的更快，更省内存空间，也就是对执行效率（时间）和资源消耗（空间）的要求。故在写算法时，要进行时间复杂度和空间复杂度分析，才能评断算法的好坏。

## 为什么要复杂度分析

> 直接拿算法进行测试，得到执行时间和占用空间大小，这叫*事后统计法*
> 1. 测试结果受测试环境影响
> 2. 测试结果受数据规模影响
> 
> 我们需要用一个不用具体数据进行测试，就能估计出算法的执行时间和占用空间的方法， 即进行时间、空间复杂度分析。

## 复杂度分析的方法（大O复杂度表示法）
### 时间复杂度分析
> 时间复杂度（Time complexity）：代码执行时间随数据规模增长的变化趋势

1. 关注循环执行次数最多的一段代码
2. 加法法则： 总时间复杂度 = 量级最大的那段代码的复杂度
    > 给定已知的循环次数，即使是10000次，十万次，也是常量级时复
    ```
    int cal(int n) { 
        int sum_1 = 0; 
        int p = 1; 
        for (; p < 1000; ++p) { 
            sum_1 = sum_1 + p; 
        } 
        
        int sum_2 = 0; 
        int q = 1; 
        for (; q < n; ++q) { 
            sum_2 = sum_2 + q; 
        } 
        
        int sum_3 = 0; 
        int i = 1; 
        int j = 1; 
        for (; i <= n; ++i) { 
            j = 1; 
            for (; j <= n; ++j) { 
                sum_3 = sum_3 + i * j; 
            } 
        } 
        
        return sum_1 + sum_2 + sum_3; }
    ```
    > 第一段代码循环大概1000次，也是常量级，时复O（1）; 第二段循环n次，时复O（n）； 第三段循环n^2次，时复O（n^2）。 所以整个函数的时复为O（n^2）

3. 乘法法则：嵌套代码复杂度 = 嵌套代码内外循环复杂度的乘积

### 常见时间复杂度实例分析
![Alt](../img/ordinaryComplexity.jpg)
1. 将对数阶O（logn）循环n次， 就是O（nlogn）
2. O（m + n）， O（m * n） 数据规模m、n均未知

### 空间复杂度分析
> 空间复杂度（Space complexity）：算法的存储空间随数据规模增长的变化趋势
> 常见空间复杂度： O（1） O（n） O（n^2）

## 最好最坏时间复杂度
## 平均时间复杂度

> find（）：假设查找x在数组中的位置，存在0 ~ n-1位置上和不在数组中，共n+1中情况，那么平均情况的复杂度=（1+2+...+n+n）/（n+1）= n（n+3）/ 2(n+1)， 去除系数、低阶、常量，时复为O（n）
>
> 以上计算方法是错误的，没有考虑每种情况的概率。x是否存在于数组的概率各占1/2， x存在于0 ~ n-1位置上的概率各为1/2n, 所以（1+2+...+n）* 1/2n + n * 1/2 = 3n + 1 / 4, 故平均时复为O（n）。加入概率的叫做加权平均值（期望值），故称为加权平均时间复杂度,简称平均时间复杂度。

## 均摊时间复杂度

```
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
> 这段代码的功能是：数组没满时，直接插入元素；数组已满时，计算所有元素的和，清空数组，并将和存放在array[0],继续插入元素。
> 1. 最好时复：数组没满，直接插入，O（1）
> 2. 最坏时复：数组已满，先求和再插入语， O（n）
> 3. 平均时复：根据插入的位置不同，分为0 ~ n-1， 和数组已满插入元素，共n+1种情况，每种情况发生的概率是1 / n+1。 而前n种的时复是O（1）， 最后一种的时复是O（n）， 所以1 * 1/n+1 + ... + 1 * 1/n+1 + n * 1/n+1 = 2n / n+1, 故平均时复为O（1）
> 4. 什么时候使用平均时复或是均摊时复？
>      
>    find（）和insert（）的对比：find（）最好情况为O（1），insert（）在大部分情况下为O（1），极端情况才为O（n）。 inset（）的时复出现是有规律的， 一次O（n）插入操作后会有n-1次的O（1）插入操作，针对这种特殊场景，不再使用较复杂的平均时复分析法， 而是采用摊还分析，求均摊时间复杂度。
> 5. 均摊时复：将耗时最多的一次O（n）操作，均摊到n-1次耗时少的O（1）操作，那么每次操作的时复都是O（1）。故均摊时复为O（1）。
 
### 什么时候用摊还分析法来估计算法的均摊时间复杂度？

当在特殊场景下，算法操作的时复有规律地分布着，看看是否能够把较高时间复杂度的操作均摊到较低时复的操作上。一般情况，均摊时复等于最好时复。 均摊时复是一种特殊的平均时复。

## 思考题

```

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```
> 最好时复：数组未满，直接添加，O（1）
> 
> 最坏时复：数组已满，扩容搬移数据后再添加，O（n）
> 
> 摊还时复： 将搬移数据的操作均摊到前n-1次直接添加的操作，时复等于直接添加的时复O（1）
> 
> 
> 