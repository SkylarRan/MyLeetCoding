# 二分查找：如何用最省内存的方式实现快速查找功能？
二分查找针对的是一个有序集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为原来的一般，知道找到该元素或者区间缩小为0。时间复杂度为O（logn），极其高效。

## 二分查找的递归与非递归实现

## 二分查找应用场景的局限性
1. 二分查找依赖的是顺序表结构，简单点说就是数组，利用了数组根据下表随机访问元素时复为O（1）的特征。
2. 二分查找针对的是有序数据
> 如果数据无序，需要先排好序。 如果针对的是一组静态数据，插入和删除操作较少，可以进行一次排序，多次二分查找。这样排序的成本可被均摊。 
> 若是有频繁地插入和删除操作,要保证在二分查找前是有序的， 要么在插入和删除数据之后就保证数据仍然有序，要么就在二分查找之前排序。这两种方式维护有序的成本都是很高的。
> 所以，二分查找只适用于插入与删除操作不频繁，一次排序多次查找的场景。针对动态变化的数据集，二叉树结构更适合查找。
3. 数据量太小不适合二分查找
> 二分查找的时复是O（logn），数据规模大才能体现出O（logn）的高效，二分查找的优势才更明显。 若数据量很小，直接顺序遍历查找就好了，小数据规模下两者的执行效率差不多。

> 若是查找过程中的比较操作很复杂，例如长字符串的对比，这时就需要尽量减少比较操作，即使数据量很小，也要选择二分查找来减少比较次数。
4. 数据量太大也不适合二分查找
> 二分查找依赖的是数组，数组就要保证数据的连续性，对内存要求比较苛刻。数据量太大很难申请到连续的内存空间来存放数据。

## 假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？
1MB = 1000 Kb = 1000000 b
1000w * 8b  = 80 000 000 b = 80MB
所以直接将所有数据存放在内存中，先用快排，再进行二分查找。 这种方式是最节省内存空间的。
散列表和二叉树是支持快速查找的动态数据结构，但在这里不行，因为存放数据会需要额外的空间，100MB肯定不够。

## 如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？
如果数据使用单链表存储且是有序的，使用快慢指针同时获取中间结点尾结点的时复是O（n），再比较元素缩小区间，那么基于有序单链表的二分查找的时复就是O（nlogn）