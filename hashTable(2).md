# 如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？

> 散列表的查询效率并不能笼统地说是O（1）， 它跟散列函数、装载因子、散列冲突等都有关。 如果散列函数设计得不好，或装载因子过高，都会使得发生散列冲突的概率升高，查询效率下降。
>
> 极端情况下，恶意攻击者精心设计散列函数，使得所有查询数据经过散列函数后都散列到同一个槽里。如果我们使用的是基于链表的解决散列冲突的方法，那么散列表则退化成链表，查询效率也由O（1）急剧退化为O（n）
>
> *散列表碰撞攻击的基本原理：*
> 假如散列表中有10万条数据，基于链表解决散列冲突的极端情况下，散列表退化为链表， 查询效率下降10万倍。也就是说如果之前100次查询只需要0.1秒，那么现在就需要1万秒。这样会因为查询操作消耗大量CPU和线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（Denial of Service， Dos）的目的。

## 如何设计散列函数

1. 散列函数设计得不能太复杂
> 散列值计算过于复杂，会影响查询操作的效率，影响散列表的性能。
2. 计算得到的散列值尽可能随机且均匀分布
> 避免或者最小化散列冲突。即使发生了散列冲突，散列到每个槽的数据也比较均匀，不会出现某个槽数据过多的情况。

## 装载因子过大怎么办？

> 对于静态数据，已知数据大小和规律，可以设计一个较好的散列函数来避免散列冲突。
>
> 对于动态数据，不知道数据的大小，所以我们提前申请的是一个一定大小的散列表空间，当插入的数据越来越多，空闲位置越少，装载因子就会越大，发生散列冲突的概率上升。 
>
> 当装载因子过大时，可以进行散列表动态扩容。 假设扩容为原空间的两倍，则原来0.8的装载因子就会降为0.4。
>
> 针对散列表扩容，搬移数据要复杂很多。因为空间大小变了，内存地址也变了，需要根据散列函数重新计算出每个数据的存储位置
> 
> 对于支持动态扩容的散列表，插入一条数据时，最好情况不需要扩容直接插入，最好时复为O（1）。最坏情况先扩容再插入数据，需要申请内存，重新计算哈希位置，搬移数据，最坏时复为O（n）。 用摊还分析法，平均时复为O（1）。
> 
> 对于删除操作，随着删除的数据越来越多，空闲位置越多，对于内存消耗有要求的，可以考虑散列表缩容

## 如何避免低效地扩容

> 最坏情况下插入一条数据前需要动态扩容，而申请内存，计算哈希位置和搬移数据的操作是很耗时的，插入操作太慢，会影响用户体验。这时，“一次性”的扩容机制就不合适。我们可以考虑把这几个步骤分开分批处理。
>
> 当装载因子达到阈值后，申请新空间，并不要立即搬移数据。当有新数据插入时，我们将新数据插入到新散列表中，并将旧散列表的一条数据插入到新散列表中。 这样就把扩容操作穿插在插入操作中，提升效率。
>
> 这种方式扩容期间，若查询数据，需将兼容新旧散列表的数据。先查找新散列表，没找到再查找旧散列表。
>
> 通过均摊方式，将数据搬移操作穿插在插入操作，把一次性扩容的代价均摊到多次插入操作之中，这样任何时刻插入一个数据的时复都是O（1），提升了散列表性能。

## 如何选择冲突解决方法

> 开放寻址法和链表法很常用，Java的LinkedHashMap采用了链表法解决冲突，ThreadLocalMap采用了通过线性探测的开放寻址法解决冲突

### 开放寻址法
> 优点: 
> 1. 数据存储在数组中，可以利用CPU缓存加快查询速度。
> 2. 数组实现的散列表，序列化简单，而链表法包含指针，序列化比较复杂
>
> 缺点：
> 1. 删除数据比较麻烦，需要特殊标记已经删除的数据。
> 2. 存放数据变多时，发生散列冲突的概率较大。所以使用开放寻址法解决冲突的散列表，装载因子的上限不能过大，
> 3. 这样又比链表法更浪费内存空间。
>
> 总结： 数据量小，装载因子小，适用开放寻址法。 这就是Java的ThreadLocalMap采用了线性探测的开放寻址法解决冲突的原因。

### 链表法
> 优点: 
> 1. 对内存空间的利用率较高。 这也是链表优于数组的地方。
> 2. 对大装载因子的容忍度高。开放寻址法只适用装载因子小于1的情况，当接近1时，可能会有大量的散列冲突，导致大量的探测、再散列等等，性能下降。对于链表法，只要散列函数计算出的值随机均匀分布，即使装载因子大于1， 也只是增加了链表的长度。查询效率虽然下降了，但比顺序查找快得多。
>
> 缺点:
> 1. 因为链表要存放指针，所以对于比较小的对象的存储，比较消耗内存。但是当存放大的对象时，指针的内存消耗在大对象面前就可以忽略不计。
> 2. 链表的结点不是连续分布，对CPU缓存不友好，对执行效率也有一定的影响。
> 
> 总结：
> 1. 对链表法进行改造。将链表法中的链表换成其他高效的动态数据结构（跳表、红黑树等）,查找时间降为O（log n）。这样也就有效地避免了散列碰撞攻击。
> 2. 基于链表的散列冲突处理方法适用于存储大对象、大数据量的散列表。而且比起开放寻址法，更加灵活，支持更多优化策略，比如用黑红树代替链表。


## 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？
1. 支持快速的查询、插入、删除操作
2. 内存占用合理，不能浪费太多的内存空间
3. 性能稳定，极端情况下，散列表的性能也不能退化到无法接受的程度

## 如何实现工业级单列表
1. 设计一个合适的散列函数
2. 定义装载因子阈值，并设计动态扩容策略
3. 选择合适的散列冲突处理方式
