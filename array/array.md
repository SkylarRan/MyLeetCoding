# Array

## 特点

### 1. 属于线性表数据结构
    
> 线性表: 就是数据元素排成一条线的样子，最多只有前后两个方向，数组、链表、栈、队列均是线性表。

> 非线性表: 数据之间不是简单的前后关系，树、图、堆等均是非线性表

### 2. 分配连续的内存空间， 存储一组具有相同类型的数据

> 因为是连续的内存空间，知道数组的首地址后，便可根据下标计算对应的元素地址，从而实现数组的按下标随机访问。

> 数组查找元素的时间复杂度为O（1）， 这种说法不正确， 应该是“数组根据下标随机访问元素的时间复杂度为O（1）”


---


## 低效的插入与删除

> 为了保证数据存放的内存空间的连续性，使得插入操作中插入位置后的元素需要依次往后移动一位， 删除操作中删除位置后的元素需要依次往前移动一位， 致使操作低效

### 1. 插入操作改进
> - 最好时复：O（1） 从尾部插入
> - 最坏时复：O（n） 从头部插入，移动n个元素
> - 平均时复：O（n） （1+2+...+n）/n

> 对于有序数组，插入操作需要依次移动元素

> 对于存放数据没有任何规律的数组，数组只是被当作一个存放数据的集合，这时的插入操作可以在将指定位置的元素移动到第n位，并在该位置存放新数据， 时复降为O（1）

### 2. 删除操作改进
> - 最好时复：O（1） 删除最后一位
> - 最坏时复：O（n） 删除头部，移动n-1个元素
> - 平均时复：O（n） （1+2+...+（n-1））/n

> 特殊场景下，并不一定追求数据的连续性。删除操作可以直接把最后一位元素放在删除位置。或者连续删除多个元素，可以先记录下删除的元素，等到数组没有更多的存储空间时，再执行一次真正的删除操作， 这样就大大减少了删除操作导致的数据搬移。

---

## 警惕数组的访问越界

> - Python :  IndexError: list index out of range
> - Java : java.lang.ArrayIndexOutOfBoundsException
> - C : 数组越界是一种未决行为，c编译器不会检查数组越界。_数组的本质就是一段连续的内存空间。_ 只要根据下标计算出的内存地址是可用的。 

```
int main(int argc, char* argv[]){ 
    int i = 0; 
    int arr[3] = {0}; 
    for(; i<=3; i++){ 
        arr[i] = 0; 
        printf("hello world\n"); 
    } 
    return 0;
}
```
> 此段C语言代码可能会无限打印。 当i=3时，arr[3]访问越界， 若arr[3] 对应的内存地址刚好是存放变量i的内存地址， 则arr[3]=0就是i=0， 然后无限循环。

---

## 容器与数组
> 针对数组类型，很多语言都提供了容器类，例如Java 的ArrayList， C++ STL的 Vector

### 1. ArrayList的特点
> 封装了很多数组操作，如插入，删除等

> 支持动态扩容。 
> - 若当前存放数据的空间已满，再添加元素时，ArrayList会将空间自动扩容1.5倍。 
> - 动态扩容操作会涉及内存申请与数据搬移，比较耗时。 若已知要存储数据的空间大小，最好在创建ArrayList时事先指定数据size。

### 2. 什么时候用数组
> - Java 的 ArrayList无法存放基本数据类型，只能存放封装类Integer、Long等，涉及Autoboxing、UNboxing有一定的性能损耗， 如果是特别关注性能，或者希望使用基本数据类型，可以用数组。
> - 如果事先知道数据的大小，对于数据的操作比较简单， 可用数组
> - 对于业务开发，使用容器省时省力，只损耗一点点性能； 对于底层开发，需要优化性能到极致，首选数组

---

## 为什么数组下标从0开始？
> 从数组特性来说，数组的实质是连续的内存空间，数组首地址即为数组中第一个元素的地址，address = heada_addr + i * 字节数，若从1开始，就变成i-1，也就多了一条减法指令，要是性能优化到极致，当然是从0开始更好。
> 历史原因： 创建c语言时规定下标从0开始，Java, Js等均效仿，方便了程序员的学习，沿用了数组下标从0开始的习惯。 python 下标可以为负。
