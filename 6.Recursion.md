# 递归
> 去的过程叫“递”， 回来的过程叫“归”

## 递归满足的三个条件 
1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解后的子问题，除了数据规模不同，求解思路要一样
3. 存在递归终止条件

## 写出递推公式，找出终止条件
> 例如上台阶问题，一次只能上1阶或者2阶，问上n阶有几种走法?
 * f(n) = f(n-1) + f(n-2)
 * f(1) = 1
 * f(2) = 2
> 则函数如下：
```
int f(int n){
    if(n == 1)  return 1;
    if(n == 2)  return 2;
    return f(n-1) + f(n-2);
}
```

## 递归代码要警惕堆栈溢出
> 函数调用使用栈来保存临时变量。每调用一个函数，都会将临时变量封装成一个栈帧压入内存栈，等函数执行完返回时才出栈。 系统栈和虚拟机栈空间一般都不大，如果递归求解的规模较大，递归层次较深，不断地压入栈，会有堆栈溢出的风险。

> 如何避免堆栈溢出？
* 限制递归调用的最大深度（计算递归次数，到达阈值则抛出异常。 ）
> 但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关

## 递归代码要警惕重复计算
> 上台阶的问题其实是会重复计算,可以引入散列表来存储计算过的值
```
int f(int n){
    if(n == 1)  return 1;
    if(n == 2)  return 2;

    //hasSolvedList是一个Map， key为n， value为f(n)
    if (hasSolvedList.containsKey(n)) { 
        return hasSolvedList.get(n); 
    }

    int ret = f(n-1) + f(n-2);
    hasSolvedList.put(n, ret);
    return ret;
}
```


## 将递归代码改写成非递归代码
* 递归的利：代码表达力强，代码简洁
* 递归的弊：重复计算、堆栈溢出、复杂度高、过多的函数调用会耗时较多

用迭代改写递归代码，相当于“手动”递归

## 递归代码调试
* 打印日志发现递归值
* 结合调试断点
